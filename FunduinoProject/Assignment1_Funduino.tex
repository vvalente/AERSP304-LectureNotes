\input{../common/notes_preamble.tex}
% !TEX root = Assignment1_Funduino.tex

\usepackage[margin=1in]{geometry} % Adjust the margin as needed
\pagenumbering{arabic}

\setlength{\droptitle}{-2cm} % Adjust the value as needed
\pagestyle{plain}

\title{AERSP304 Funduino Project\\Assignment 1}
\author{Spring 2026}
\date{Due: 04/08/2026 11:59 PM}

\begin{document}
\maketitle
% Start here

\section{Simulating a DC Motor}
This following project is intended to present some basic ideas of system identification and control. The actuator that will be used is an electric DC motor. Your first task in this series of experiments will be to identify a transfer function depicting the relationship between input (voltage) and output (angular speed) of the motor.

A DC-motor with an encoder is used for this Arduino assignment. The electrical and mechanical differential equations governing the dynamic system will be derived later. For now, let's understand how this actuator works.

An electrical motor is a machine that converts electrical energy (voltage) in mechanical energy (torque). Figure \ref{fig:MotorModel} shows a schematic diagram for a DC-motor. The basic principle is that whenever a current carrying conductor is placed in a magnetic field, it experiences a mechanical force. When an input DC voltage $V_a$ is applied to its terminals, a current $i_a$ develops and accelerates the motor due to the force generated due to the magnetic field. In most general cases, the magnetic field is generated by permanent magnets positioned inside the structure of the motor. A commutator is used in the interface between the static part and the rotational part in order to achieve unidirectional torque. As long as the DC voltage supply stays connected and providing enough power, the shaft will keep rotating with an angular speed $\omega$. Once there are also conductors rotating in the magnetic field, a back-
EMF $V_g$ is generated in the opposite direction trying to compensate that excitation.

\begin{figure}[h]
	\centering
	\includegraphics[scale=1.0]{figures/MotorModel.png}
	\caption{Schematics for the motor.}
	\label{fig:MotorModel}
\end{figure}

Other parameters of the motor are its inductance $L_a$ and the armature resistance $R_a$. On the mechanical side there is the shaft inertia $J$. For a simplistic model, the torque associated with friction, $T$ is negligible.

\subsection{Mathematical model of the DC motor}
Once the current is developed through the conductor, there are three voltage drops that can be represented by mathematical equations in the electrical side of the actuator. Using Kirchhoff's voltage law:

\begin{equation}
L_a \frac{di_a}{dt} = V_a - R_a\cdot i_a - V_g
\label{electricSide}
\end{equation}

When the armature is conducting current in the magnetic field, it produces a mechanical torque on the shaft proportional to the current. So:

\begin{equation}
T = K_m\cdot i_a.
\label{mechanicalSide1}
\end{equation}

As it rotates in the magnetic field it also generates a voltage proportional to the speed of rotation:

\begin{equation}
V_g = K_g\cdot \omega.
\label{back_emf}
\end{equation}

The angular velocity is defined as:

\begin{equation}
\omega(t) = \frac{d\theta}{dt} = \dot{\theta}(t).
\label{angularVel}
\end{equation}

On the mechanical side, $F=m \cdot a$ is applied in rotational form and related to (\ref{mechanicalSide1}) that:

\begin{equation}
J\frac{d\omega}{dt} = K_m\cdot i_a
\label{mechanicalSide}
\end{equation}

These equations are the basis for mathematical model of the DC motor in this project.

\section{Transfer functions}
Prior to experimentally determining the transfer function, use equations (\ref{electricSide}) to (\ref{mechanicalSide}) to derive theoretically (keep all parameters in a generic form):
\begin{enumerate}
	\item the transfer function between the angular velocity and the input voltage $G(s)=\frac{\omega(s)}{V_a(s)}$;
	\item the position transfer function $H(s)=\frac{\theta(s)}{V_a(s)}$;
\end{enumerate}

\section{Transfer Function Identification}
\label{LSM}
Even though, we can mathematically model the motor but we do not know the values of different parameters appearing in these equations. In this section, we will use the experimental data to identify the equivalent transfer function for the motor.
%In order to apply the method for system identification it is necessary to know some of the components you will be using in this first assignment.
The basic idea is to apply different voltages in the input and then measure the response of the motor in its angular velocity. Also, make sure that you use the appropriate time interval for both saving the voltage as well as for identifying and saving the angular velocity. A good time interval will provide enough points in every change of level. Make sure that you also wait until the motor settles in the new set point before changing it. %A good reference shape would be similar to a square wave.
The next two sections explain how to record the input (voltage) and output (angular velocity) of the motor.

\subsection{Rotary encoder}
Generally motor is equipped with an encoder which provides the angular speed of the motor. As an example here, the model RK-370SD-2470 DC 6V is equipped with a simple encoder to measure rotation of the motor shaft. The encoder uses $n=12$ holes with a so called quadrature design, meaning it has a resolution of 48 pulse changes per revolution. To compute the counts per revolution of the gearbox output, multiply the gear ratio by 48. The gear ratio for this model is 9.68:1.

A good strategy is to use fast input counters or interruption to read pulses from the encoder. That will help to achieve a more accurate model.

\subsection{Measuring voltage}
The other important information is the voltage applied to the motor. There are several ways to do that but the simplest one (not the most accurate though) is converting the Pulse-Width Modulation (PWM) signal to voltage levels by simply multiplying the volt/level ratio. It will be necessary to know what is the DC supply voltage and the total number of levels (8 bit, 16 bit or other) of the PWM signal.

A second option to measure the voltage applied to the motor is using analog inputs. Be careful because some Arduino boards allows a 5V maximum level in the analog inputs. Applying values higher than those could damage the board. If that is the case, it is necessary to use some conditioning circuit as explained in your earlier getting started document.

\subsection{MATLAB and Arduino}
You can use both MATLAB or Arduino code to generate the signals to be used on the Arduino, as well as to analyze the output of data from the Arduino during the experiments. Feel free to chose the one you are comfortable with. You will need to save and read data. To keep control over the format the data is saved in, low level read and write functions will be used. Make sure you check the help for all the functions described in the following!

If using MATLAB, for example, to open a file simply use the \textit{fopen} command. But donâ€™t forget to close the file with \textit{fclose} once your finished with writing or reading. Writing is done using \textit{fprintf} and reading is done using \textit{fscanf}. The easiest is to look at an example on how to use them. First we will write a vector \textit{a} into a file \textit{write.txt}:
\begin{figure}[h]
	\centering
	\includegraphics[scale=1]{figures/fscan.png}
\end{figure}
Reading is done in a similar way. We will read the data we just created in a vector \textit{b}:
\begin{figure}[h]
	\centering
	\includegraphics[scale=1]{figures/fopen.png}
\end{figure}

Another way to do is to send the information to MATLAB and then just store it in a variable for processing. An example is provided as two separate files: \textit{recv.m} is a script in MATLAB that plots two variables received by serial from Arduino. \textit{Example.ino} is the code to run inside the Arduino board in order to send those two variables to MATLAB. It is a 10s simulation. Feel free to use and modify those programs.
\subsection{Transfer Function Identification}

This section lists the main steps for you to identify the transfer function for the DC motor.

\begin{enumerate}
%\item Write an Arduino or Matlab program to generate input voltage for the motor. For this purpose, use the \textit{chirp} command in the Matlab which provides a sinusoidal function of specified frequency range, sample time and length. Note  that you can easily create a chirp signal in Arduino by making use of the following equation:
%$$V_a(t)=A\sin\left(\phi_0+2\pi\left(\frac{c}{2}t^2+\omega_0 t\right)\right),\ \ c=\frac{\omega_1-\omega_0}{T}$$
%Save this input voltage data in a file to be read in Arduino or you can directly send the data to the Arduino.
%\item Write an Arduino or Matlab function which apply the voltage to the motor according to the voltage data generated in the previous step and will read the encoder data (angular speed) and will save this information along with the input voltage information in a file.
%\item Write a Matlab program to compute the parameters of the difference equation using the equation (\ref{lsqpara}).
%\item Use equation (\ref{finiteDifference}) along with input voltage data to estimate motor response according to the difference equation of (\ref{finiteDifference}).
%\item Compute error between measure motor response (i.e, encoder data) and estimated motor response from the previous step.
%\item Repeat steps 1-5 at least five times to compute the parameters of the motor difference equation. Average the coefficients generated using the least squares fit to get the best estimate of these parameters. Also, compute the standard deviation of these parameters.
%\item Repeat the data acquisition process at least two more times, and compare the input and outputs using your best estimate of the model parameters. You are encouraged to pick some time varying input which you may not have used in the earlier steps.

\item Write an Arduino or Matlab program to command a voltage input to the motor and read the encoder data to get the RPM of the motor. Command a step input corresponding to $80\%$ of maximum voltage which your motor can sustain. Since the motor has dynamics (inertia, friction, etc.), it doesn't instantaneously reach top speed when turned on and doesn't immediately come to a stop when turned off. It takes time for the motor to react. You should record at least 10 seconds worth of data for each commanded voltage input. Motor RPM recorded may be noisy depending upon the prescribed sampling time. Vary the sampling time between 0.1 second to 0.01 second to find the appropriate sampling time for which motor RPM data is not very noisy.  Save the encoder data (RPM) along with the commanded voltage input in a file.

\item Open the saved data file from the previous step in Matlab and plot RPM vs. time. You will notice that RPM vs. time graph looks like a first order model response than the second order model. This is due to the fact that the motor is overdamped. This is typical of a DC motor where the mechanical dynamics are much slower than the electrical dynamics, and hence dominate the response. So, we can estimate the motor transfer function as:
\begin{equation}
G(s)=\frac{\omega(s)}{V_a(s)}=\frac{K}{\tau s+1}
\end{equation}
where $K$ is the DC gain, i.e., ratio of steady state RPM to applied voltage. For example, if we apply a voltage of 6V and motor RPM is estimated to be 170 RPM, then $K=\frac{170RPM}{6V}$. $\tau$ is the time it takes for motor to reach the $63.2\%$ of its steady state RPM.

\item From RPM vs. time plot, record the motor RPM in steady state. You will need to ``eye-ball'' a fitted line to the motor's RPM graph. Also, note down the time, $\tau$, it takes to reach the approximately 63.2\% of its total RPM. Use these values to identify the motor transfer function.

\item Use the identified transfer function to predict motor RPM in Matlab. Compute error between measured motor response (i.e, encoder data) and  predicted motor response from the previous step.
\item Repeat steps 1-4 at least five times to compute the parameters of the transfer function by varying the amplitude of commanded input voltage. Average the transfer function parameters, $K$ and $\tau$ to get the best estimate of these parameters. Also, compute the standard deviation of these parameters.
\item Use the \textit{chirp} command in Matlab to generate an input voltage profile for the motor. The \textit{chirp} command provides a sinusoidal function of specified frequency range, sample time and length. Predict motor response for the \textit{chirp} signal while making use of identified transfer function. Note  that you can easily create a chirp signal in Arduino by making use of the following equation:
$$V_a(t)=A\sin\left(\phi_0+2\pi\left(\frac{c}{2}t^2+\omega_0 t\right)\right),\ \ c=\frac{\omega_1-\omega_0}{T}$$

Apply the chirp input voltage to the motor and record the motor response.  Compute error between measured motor response (i.e, encoder data) and  predicted motor response. You are encouraged to pick different \textit{chirp} signals by varying the frequency and amplitude.

\end{enumerate}

%In this section, we will use the least squares method to identify the unknown parameters of our transfer function. Since the motor transfer function is second order, we can write the output of the motor at the $n^{th}$ time step as a linear combination of output and input of the motor at previous two steps:
%\begin{equation}\label{finiteDifference}
%y(n+1) = b_0\cdot u(n) + b_1\cdot u(n-1) - a_0\cdot y(n) - a_1\cdot y(n-1)
%\end{equation}
%where the variable $y(n)$ donates the output (angular speed measured by encoder) at the $n^{th}$ time step and $u(n)$ represents the input voltage at the $n^{th}$ time step.
%%%For this experiment it is chosen a second order model with four undetermined coefficients. So the idea is by using Least Square Method to identify these four parameters. The transfer function is then:
%%
%%\begin{equation}
%%\label{laplace}
%%\frac{\omega(s)}{V_a(s)} = \frac{b_0\cdot s + b_1}{s^2 + a_0\cdot s + a_1}
%%\end{equation}
%Note $b_0,\ b_1,\ a_0$ and  $a_1$ are unknown parameters which will be function of physical variables $L_a,\ R_a, K_m$ and $K_g$. In the vector-matrix form, we can write:
%%
%%Transforming this into matrix form for all measurements, $y$:
%\begin{align}
%\underbrace{\left\{
%\begin{array}{c}
%y(3)\\
%y(4)\\
%y(5)\\
%\vdots\\
%y(N)
%\end{array}
%\right\}}_{\mathbf{Y}}
%=
%\underbrace{\left[
%\begin{array}{c c c c}
%-y(2) & -y(1) & u(2) & u(1) \\
%-y(3) & -y(2) & u(3) & u(2) \\
%-y(4) & -y(3) & u(4) & u(3) \\
%\vdots & \vdots & \vdots & \vdots \\
%-y(N-1) & -y(N-2) & u(N-1) & u(N-2)
%\end{array}
%\right]}_{\mathbf{A}}
%\underbrace{\left\{
%\begin{array}{c}
%a_0\\
%a_1\\
%b_0\\
%b_1
%\end{array}
%\right\}}_{\mathbf{x}}
%\end{align}
%
%We can write this as:
%\begin{align}
%\mathbf{Y} = \mathbf{A} \mathbf{x}
%\end{align}
%
%In order to identify the system well and reduce measurement noise as much as possible, a lot of data should be collected. This will provide with an over determined system (i.e, $N>>4$). An over determined system can't be solved exactly, so, instead it is possible try to minimize the error square:
%\begin{align}
%\mathbf{e} &= \mathbf{Y} -\mathbf{A} \mathbf{x}\\
%J &= \frac{1}{2} \mathbf{e}^T \mathbf{e} = \frac{1}{2}(\mathbf{Y} -\mathbf{A} \mathbf{x})^T(\mathbf{Y} -\mathbf{A}\mathbf{x})
%\end{align}
%
%A necessary condition for $J$ to be minimal is that the gradient of $J$ with respect to $\mathbf{x}$ is 0:
%\begin{equation}
%\nabla_{\mathbf{x}} J = 0 = -\mathbf{A}^T\mathbf{Y} + \mathbf{A}^T\cdot \mathbf{A}\mathbf{x}
%\end{equation}
%which leads to:
%\begin{equation}\label{lsqpara}
%\mathbf{x} = (\mathbf{A}^T\cdot\mathbf{A})^{-1}\mathbf{A}^T\mathbf{Y}
%\end{equation}
%$(\mathbf{A}^T\mathbf{A})^{-1}\mathbf{A}^T$ is called a pseudo inverse. %The MA. Make sure to check the help information for this command before using it.

%\section{Arduino input generation}
%
%With respect to completing this project, your tasks are as follows:
%
%
%%	\item Write two MATLAB functions: your first function should generate chirp signals (use the \textbf{chirp} command in the Matlab) of specified frequency range, sample time and length (those three will be inputs to the function) and save it in a file such that the Arduino can read it. The second function will get the file name where Arduino stored the measured data and should compute the parameters of the difference equation using the equation (\ref{lsqpara}).
%%	\item Write one MATLAB function and one Arduino function: the Arduino function will generate signals with frequency and amplitudes and will read the angular speed of the motor as well as save all information in a file (or send it to MATLAB). The MATLAB function will read this file (or receive it by serial) and then process it to identify the parameters of the difference equation using the algorithm described in the identification part in section [\ref{LSM}].
%\end{enumerate}

%In both cases, you will generate signals of different sampling rates to identify the parameters of the DC-motor. Export these so you can use them with the Arduino, generate the responses of the DC-motor from these signals, and import those responses into MATLAB for processing.

%\begin{equation}
%e = \mathbf{Y} -\mathbf{A} \mathbf{x}\\
%\end{equation}

\section{Generating Report}

Show all your steps to produce your transfer function estimates. Clearly indicate the results of your transfer function identification as well as the error analysis conducted. Explain the signals used to determine the system and why those inputs were chosen. Comment on your results qualitatively. Include any figures or plots used for the analysis.

If any methods beyond what are outlined above are used to complete this assignment, please outline them in the report. For example, if you produce the signals directly in Arduino for the inputs to the motor, please detail how this was done and what the results were. The explanations above for the methods to produce the inputs and outputs are not the sole way to do them for this assignment. You are welcome and encouraged to use whatever approach provides the results that are expected.

\section{Potentially Useful Links}
\begin{enumerate}
    \item \href{https://www.youtube.com/watch?v=dTGITLnYAY0\&ab\_channel=CurioRes}{https://www.youtube.com/watch?v=dTGITLnYAY0\&ab\_channel=CurioRes}
    \item \href{https://www.mathworks.com/discovery/arduino-programming-matlab-simulink.html}{https://www.mathworks.com/discovery/arduino-programming-matlab-simulink.html}
    \item \href{https://www.mathworks.com/hardware-support/arduino-matlab.html}{https://www.mathworks.com/hardware-support/arduino-matlab.html}
    \item \href{https://www.mathworks.com/help/signal/ref/chirp.html}{https://www.mathworks.com/help/signal/ref/chirp.html}
    \item \href{https://www.arduino.cc/en/Reference/FileRead}{https://www.arduino.cc/en/Reference/FileRead}
\end{enumerate}

% End here
\end{document}